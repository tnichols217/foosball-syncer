import { GoogleSpreadsheet } from 'google-spreadsheet';
import { JWT } from 'google-auth-library'
import dotenv from "dotenv"
let env = dotenv.config().parsed as any

const SPREADSHEET = "1ajVhu1WlCYArATAQM2suTGiz1PKv6PIXSUqJBT5e_hM"
const SUBMIT_PREINTERVAL = 60*1000 // 1 minute interval for validation
const SUBMIT_INTERVAL = 10*60*1000 // 10 minutes interval for validation

const serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    email:  env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
    key: env.GOOGLE_PRIVATE_KEY.replace(/\\n/g, '\n'),
    scopes: [
        'https://www.googleapis.com/auth/spreadsheets',
    ],
});

type UsersRowData = {
    "Timestamp": string;
    "Email Address": string;
    "Action": 'Submit Scores' | 'Validate Scores';
    "Scores": string;
    "Case ID of opponent": string;
    "Agree to the scores submitted by opponent?": "Yes" | "No";
};

const COLUMN = {
    TIMESTAMP: "Timestamp",
    EMAIL: "Email Address",
    ACTION: "Action",
    SCORES: "Scores",
    CASE_ID_OF_OPPONENT: "Case ID of opponent",
    AGREE: "Agree to the scores submitted by opponent?"
} as {[key: string]: keyof UsersRowData}

type Scores = [number, number][];

type ParsedRowData = {
    "Timestamp": Date;
    "Submitter": string;
    "Submit": boolean;
    "Scores": Scores;
    "Opponent": string;
};

const parseRowData = (rowData: UsersRowData): ParsedRowData => {
    return {
        "Timestamp": new Date(rowData["Timestamp"]),
        "Submitter": rowData["Email Address"].split("@")[0],
        "Submit": rowData["Action"] === "Submit Scores",
        "Scores": rowData["Scores"].split("\n").filter(row => row.length >= 3).map(row => row.split("-").map(a => parseInt(a))),
        "Opponent": rowData["Case ID of opponent"]
    } as ParsedRowData
}

const bucketInputs = (rowData: ParsedRowData[]): ParsedRowData[] =>
    rowData.filter(row => row.Submit && row.Scores.length > 0).sort((a, b) => a.Timestamp.getTime() - b.Timestamp.getTime())

const bucketValidators = (rowData: ParsedRowData[]): ParsedRowData[] =>
    rowData.filter(row => !row.Submit).sort((a, b) => a.Timestamp.getTime() - b.Timestamp.getTime())

const matchValidators = (validators: ParsedRowData[], inputs: ParsedRowData[]): ParsedRowData[] => {
    let o: ParsedRowData[] = []
    for ( let inp of inputs ) {
        validators.splice(0, validators.findIndex(val => inp.Timestamp.getUTCMilliseconds() - val.Timestamp.getUTCMilliseconds() < SUBMIT_PREINTERVAL))
        let valid = validators.findIndex(val => inp.Opponent == val.Submitter && val.Timestamp.getUTCMilliseconds() - inp.Timestamp.getUTCMilliseconds() < SUBMIT_INTERVAL)
        if (valid != -1) {
            o.push(inp)
            validators.splice(valid, 1)
        }
    }
    return o
}

type pointData = {
    Bias: number;
    Weight: number;
}

const SETWEIGHT = 0;
const MATCHWEIGHT = 0;
const ALLWEIGHT = 0;

const weightTime = (time: Date, now: Date = new Date()): number => {
    let diff = now.getUTCMilliseconds() - time.getUTCMilliseconds()
    const halfLife = 14*24*60*60*1000; // 14 days
    return Math.pow(0.5, (diff / halfLife))
}

const matchToPointData = (row: ParsedRowData): pointData[] => {
    let timeWeight = weightTime(row.Timestamp)
    let o = row.Scores.map(score => {
        return {
            Bias: score[0] / score[1],
            Weight: (score[0] + score[1] + ALLWEIGHT) * timeWeight
        } as pointData
    })
    let sets = row.Scores.reduce<[number, number]>((a, b) => { return [a[0] + +(b[0] > b[1]), a[1] + +(b[0] < b[1])] }, [0, 0])
    o.push({
        Bias: sets[0] / sets[1],
        Weight: (sets[0] + sets[1] + ALLWEIGHT) * SETWEIGHT * timeWeight
    }, {
        Bias: +(sets[0] > sets[1]),
        Weight: (MATCHWEIGHT + ALLWEIGHT) * timeWeight
    })

    return o
}

const WEIGHTWEIGHT = 1.5; // Weight combination weight

const combinePointData = (pointData: pointData[]): pointData => {
    let Weights = pointData.map(p => p.Weight)
    let Bias = pointData.map(p => p.Bias * p.Weight).reduce((a, b) => a + b)/Weights.reduce((a, b) => a + b)
    let Weight = Math.pow(Weights.map(w => Math.pow(w, WEIGHTWEIGHT)).reduce((a, b) => a + b), 1/WEIGHTWEIGHT)
    return {
        Bias: Bias,
        Weight: Weight
    }
}

const doc = new GoogleSpreadsheet(SPREADSHEET, serviceAccountAuth);
doc.loadInfo().then(async () => {
    const sheet = doc.sheetsByIndex[0];
    const userRows = await sheet.getRows<UsersRowData>();
    const parsedRows = userRows.map(row => parseRowData(row.toObject() as UsersRowData));
    const verifiedInputs = matchValidators(bucketValidators(parsedRows), bucketInputs(parsedRows))
    const pointData = verifiedInputs.map(row => matchToPointData(row))

    console.log(pointData);
});